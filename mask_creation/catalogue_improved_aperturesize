from astropy.io import fits
import matplotlib.pyplot as plt
import numpy as np
from scipy.ndimage import label, center_of_mass
import pandas as pd
from skimage.draw import disk


# from photutils import aperture_photometry, CircularAperture
path="fits_file/mosaic.fits"
#get threshold from other program!!!!!!!!
threshold = 3481

#open file and get data
hdulist = fits.open(path)
data = hdulist[0].data


#for now only work with part of the image with side length 1/10 of the image
side=data.shape[0]//4
data = data[:side, :side]

#create mask
binary_mask= data > threshold

# Use label to identify connected regions in the binary mask
labeled_image, num_galaxies = label(binary_mask)

print(f"Number of detected objects (galaxies): {num_galaxies}")

print(labeled_image)

#Find the center of mass for each labeled region
centroids = []  # List to store (y, x) coordinates of each centroid
initialmeanthresh=4
ysmall=False
ybig=False
xsmall=False
xbig=False
for i in range(1, num_galaxies + 1):
    
    # Calculate the center of mass for the current object
    y_center, x_center = center_of_mass(binary_mask, labeled_image, i)
    print(f"these the preliminary x and y coordinates {x_center} and {y_center}")
    #do it 3 times at least
    for j in range(3):
        meanthresh=initialmeanthresh
        #check object not in the edge of the image
        if int(y_center)-meanthresh<0:
            meanthresh=int(y_center)
            ysmall=True
        if int(y_center)+meanthresh>data.shape[0]:
            meanthresh=int(data.shape[0]-y_center)
            ybig=True
        if int(x_center)-meanthresh<0 and ysmall==False and ybig==False:
            meanthresh=int(x_center)
            xsmall=True
        if int(x_center)+meanthresh>data.shape[1] and ysmall==False and ybig==False:
            meanthresh=int(data.shape[1]-x_center)
            xbig=True
        if ysmall==True and xsmall==True:
            #take smallest
            meanthresh=min(y_center,x_center)
        if ysmall==True and xbig==True:
            #take smallest
            meanthresh=int(min(y_center,data.shape[1]-x_center))
        if ybig==True and xsmall==True:
            #take smallest
            meanthresh=int(min(data.shape[0]-y_center,x_center))
        if ybig==True and xbig==True:
            #take smallest
            meanthresh=int(min(data.shape[0]-y_center,data.shape[1]-x_center))
        print(f"this is meanthresh {meanthresh}")
        #check around area of side meanthresh for the centroid
        datainrange=data[int(int(y_center)-meanthresh):int(int(y_center)+meanthresh), int(int(x_center)-meanthresh):int(int(x_center)+meanthresh)]
        #find max and index of max
        maxval=np.max(datainrange)
        maxindex = np.unravel_index(np.argmax(datainrange), datainrange.shape)

        # maxindex is a tuple (row_index, col_index), so we need to unpack it
        y_offset, x_offset = maxindex
        y_center=int(y_center)-meanthresh+y_offset
        x_center=int(x_center)-meanthresh+x_offset
    
    
    centroids.append((y_center, x_center))
    print(f"Centroid of object {i} found")

# Initialize variables as before
fraction_threshold = 0.8  # Adjust this as needed (do trial and error?)
aperture_radii = []
for i, (y_center, x_center) in enumerate(centroids, start=1):
    # print("here is the data")
    # print(data[int(int(y_center)-meanthresh):int(int(y_center)+meanthresh), int(int(x_center)-meanthresh):int(int(x_center)+meanthresh)])
    
    #Intensity at centroid (for comparison)
    #take the intensity around the centroid
          
    centroid_intensity = data[int(y_center), int(x_center)]
    initial_area = np.sum(labeled_image == i) # Number of pixels in the current object
    initial_radius = np.sqrt(initial_area / np.pi) #estiamte the radius of the object given number of pixel comprising it

    # Initialize radius and calculate mean intensity within current aperture
    radius = int(initial_radius)

    while True:
        # Define annular region just outside the current radius
        outer_radius = int(radius + 1)
        annular_mask = disk((y_center, x_center), outer_radius, shape=data.shape) #take pixels within a disk around the centroid

        # Calculate mean intensity in the annular region
        annular_mean_intensity = data[annular_mask].mean() #calcualte the mean intensity of the pixels in the outer disk
        
        #Stop when annular mean falls below a fraction of centroid intensity
        print(f"Mean intensity in annular region: {annular_mean_intensity}")
        print(f"Fraction of centroid intensity: {fraction_threshold * centroid_intensity}")
        if annular_mean_intensity < fraction_threshold * centroid_intensity:
            break
        if radius>initial_radius*2:
            break
        # Expand radius for the next iteration
        radius += 1
        print(f"trying to find radius of object {i} expanded to {radius}")

    # Store final radius and mean intensity within the final aperture
    print(f"Found radius for object {i}")
    aperture_radii.append(radius)

aperture_positions = centroids
aperatures= []
#create aperature for each galaxy with the radius calculated before
for i, (y_center, x_center) in enumerate(aperture_positions, start=1):
    radius = aperture_radii[i-1]
    #aperature is true when data is in the aperature and false when not
    aperature = disk((y_center, x_center), radius, shape=data.shape) 
    print(f"Aperture {i} created")
    aperatures.append(aperature)
    
#calculate the intensity of each galaxy as mean of the pixels in the aperature and add it to dictionary with x and y coordinates by labelling the aperatures

# Calculate the intensity of each object
intensities = []
for i, aperture in enumerate(aperatures, start=1):
    # Calculate the mean intensity within the current aperture
    intensity = data[aperture].mean()
    intensities.append(intensity)
    print(f"Intensity of object {i} calculated")

#create dictionary with x and y coordinates and intensity
galaxies = []
for i, (y, x) in enumerate(centroids, start=1):
    galaxy = {"x": x, "y": y, "intensity": intensities[i-1]}
    galaxies.append(galaxy)

#create csv file with geader x, y and intensity and values of the galaxies
df = pd.DataFrame(galaxies)
#only pick out top 10 high intensity galaxies
df_largest = df.nlargest(10, "intensity")

#transform df to cat file
cat_file = "galaxies.cat"
with open(cat_file, "w") as f:
    f.write("# x y intensity\n")
    for i, row in df.iterrows():
        f.write(f"{row['x']} {row['y']} {row['intensity']}\n")
        
cat_highintensity_file = "highestintensity_galaxies.cat"   
with open(cat_highintensity_file, "w") as f:
    f.write("# x y intensity\n")
    for i, row in df_largest.iterrows():
        f.write(f"{row['x']} {row['y']} {row['intensity']}\n")

#transform from df to votable file
from astropy.table import Table
from astropy.io.votable import writeto
vot_file = "galaxies.vot"
table= Table.from_pandas(df)
writeto(table, vot_file)
print("vot File created")
vot_highintensity_file = "highestintensity_galaxies.vot"
table_highintensity= Table.from_pandas(df_largest)
writeto(table_highintensity, vot_highintensity_file)


#save file

#close fits file
hdulist.close()